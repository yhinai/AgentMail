// @ts-nocheck - TODO: Update to match new AutoBazaaar schema after Convex deployment
// Convex database client for ProfitPilot
import { ConvexHttpClient } from 'convex/browser';
import {
  TransactionSchema,
  ProductSchema,
  BuyerProfileSchema,
  NegotiationStateSchema,
  MetricsSchema,
} from './models';
import type { Transaction, Product, BuyerProfile, NegotiationState, Metrics } from '../types';
// Import Convex API functions
// Note: These need to be generated by Convex after running `npx convex dev`
// For now, we'll use a dynamic import pattern
let api: any;
try {
  // Try to import from generated convex directory
  api = require('../../convex/_generated/api');
} catch {
  // Fallback: API will be undefined, will use mock mode
  console.warn('Convex API not generated. Run `npx convex dev` to generate.');
}

export class DatabaseClient {
  private client?: ConvexHttpClient;
  private convexUrl: string;
  private useMockMode: boolean = false;

  // In-memory storage for mock mode
  private mockTransactions: Map<string, TransactionSchema> = new Map();
  private mockProducts: Map<string, ProductSchema> = new Map();
  private mockNegotiations: Map<string, NegotiationStateSchema> = new Map();

  constructor() {
    this.convexUrl = process.env.NEXT_PUBLIC_CONVEX_URL || process.env.CONVEX_URL || '';

    // Check if URL is valid (not placeholder)
    const isValidUrl = this.convexUrl &&
                       this.convexUrl !== 'your_convex_url_here' &&
                       (this.convexUrl.startsWith('https://') || this.convexUrl.startsWith('http://'));

    if (!isValidUrl) {
      console.warn('⚠️  Convex URL not configured. Using mock/in-memory mode.');
      console.warn('   Set CONVEX_URL in .env to enable database persistence.');
      this.useMockMode = true;
    } else {
      this.client = new ConvexHttpClient(this.convexUrl);
      console.log('✅ Convex database client initialized');
    }
  }

  // Transaction operations
  // TODO: Update to match new Transaction schema from AutoBazaaar
  async createTransaction(data: Omit<Transaction, 'id' | 'createdAt'>): Promise<Transaction> {
    // Temporarily disabled - needs update to match new schema
    console.warn('createTransaction is disabled - needs schema update');
    return {
      ...data,
      id: this.generateId(),
      createdAt: Date.now(),
    };
  }

  async getTransaction(id: string): Promise<Transaction | null> {
    // TODO: Implement with new schema
    console.warn('getTransaction is disabled - needs schema update');
    return null;
  }

  async updateTransaction(id: string, updates: Partial<Transaction>): Promise<Transaction> {
    // TODO: Implement with new schema
    console.warn('updateTransaction is disabled - needs schema update');
    throw new Error('updateTransaction not implemented');
  }

  async getTransactionsByBuyer(email: string): Promise<Transaction[]> {
    // TODO: Implement with new schema
    console.warn('getTransactionsByBuyer is disabled - needs schema update');
    return [];
  }

  // Product operations
  async createProduct(data: Omit<Product, 'id' | 'createdAt'>): Promise<Product> {
    if (!this.convexUrl) {
      // Mock implementation
      const product: ProductSchema = {
        _id: this.generateId(),
        _creationTime: Date.now(),
        title: data.title,
        description: data.description,
        cost: data.cost,
        targetPrice: data.targetPrice,
        category: data.category,
        images: data.images,
        condition: data.condition,
      };
      return this.schemaToProduct(product);
    }

    const productId = await this.client.mutation(api.createProduct, {
      title: data.title,
      description: data.description,
      cost: data.cost,
      targetPrice: data.targetPrice,
      category: data.category,
      images: data.images,
      condition: data.condition,
    });

    const product = await this.client.query(api.getProduct, { id: productId });
    if (!product) {
      throw new Error('Failed to create product');
    }
    return this.schemaToProduct(product as ProductSchema);
  }

  async getProduct(id: string): Promise<Product | null> {
    if (!this.convexUrl) {
      return null;
    }
    const product = await this.client.query(api.getProduct, { id: id as any });
    return product ? this.schemaToProduct(product as ProductSchema) : null;
  }

  async getAllProducts(): Promise<Product[]> {
    if (!this.convexUrl) {
      return [];
    }
    const products = await this.client.query(api.getAllProducts, {});
    return products.map(p => this.schemaToProduct(p as ProductSchema));
  }

  // Buyer Profile operations
  async getBuyerProfile(email: string): Promise<BuyerProfile | null> {
    if (!this.convexUrl) {
      return null;
    }
    const profile = await this.client.query(api.getBuyerProfile, { email });
    return profile ? this.schemaToBuyerProfile(profile as BuyerProfileSchema) : null;
  }

  async updateBuyerProfile(email: string, updates: Partial<BuyerProfileSchema>): Promise<void> {
    if (!this.convexUrl) {
      return;
    }
    await this.client.mutation(api.updateBuyerProfile, { email, updates });
  }

  private schemaToBuyerProfile(schema: BuyerProfileSchema): BuyerProfile {
    return {
      email: schema.email,
      purchaseHistory: [],
      priceSensitivity: schema.priceSensitivity,
      negotiationStyle: schema.negotiationStyle,
      communicationPreference: schema.communicationPreference,
      conversionProbability: 0.5,
      lastInteraction: schema.lastInteraction ? new Date(schema.lastInteraction) : undefined,
      totalSpent: schema.totalSpent,
      averageDiscount: schema.averageDiscount,
    };
  }

  // Negotiation State operations
  async createNegotiationState(data: Omit<NegotiationState, 'id'>): Promise<NegotiationState> {
    if (!this.convexUrl) {
      // Mock implementation
      const negotiation: NegotiationStateSchema = {
        _id: this.generateId(),
        _creationTime: Date.now(),
        buyerEmail: data.buyerEmail,
        product: data.product,
        threadId: data.threadId,
        currentPrice: data.currentPrice,
        initialPrice: data.initialPrice,
        minPrice: data.minPrice,
        rounds: data.rounds,
        offers: data.offers.map(offer => ({
          price: offer.price,
          from: offer.from,
          timestamp: offer.timestamp.getTime(),
        })),
        status: data.status,
        listingUrls: data.listingUrls,
        agreedPrice: data.agreedPrice,
      };
      return this.schemaToNegotiation(negotiation);
    }

    const negotiationId = await this.client.mutation(api.createNegotiationState, {
      buyerEmail: data.buyerEmail,
      product: data.product,
      threadId: data.threadId,
      currentPrice: data.currentPrice,
      initialPrice: data.initialPrice,
      minPrice: data.minPrice,
      rounds: data.rounds,
      offers: data.offers.map(offer => ({
        price: offer.price,
        from: offer.from,
        timestamp: offer.timestamp.getTime(),
      })),
      status: data.status,
      listingUrls: data.listingUrls,
      agreedPrice: data.agreedPrice,
    });

    const negotiation = await this.client.query(api.getNegotiationState, { threadId: data.threadId });
    if (!negotiation) {
      throw new Error('Failed to create negotiation state');
    }
    return this.schemaToNegotiation(negotiation as NegotiationStateSchema);
  }

  async getNegotiationState(threadId: string): Promise<NegotiationState | null> {
    if (!this.convexUrl) {
      return null;
    }
    const negotiation = await this.client.query(api.getNegotiationState, { threadId });
    return negotiation ? this.schemaToNegotiation(negotiation as NegotiationStateSchema) : null;
  }

  async updateNegotiationState(threadId: string, updates: Partial<NegotiationState>): Promise<void> {
    if (!this.convexUrl) {
      return;
    }
    await this.client.mutation(api.updateNegotiationState, {
      threadId,
      updates: {
        currentPrice: updates.currentPrice,
        rounds: updates.rounds,
        offers: updates.offers?.map(offer => ({
          price: offer.price,
          from: offer.from,
          timestamp: offer.timestamp.getTime(),
        })),
        status: updates.status,
        agreedPrice: updates.agreedPrice,
      },
    });
  }

  // Metrics operations
  async getMetrics(): Promise<Metrics> {
    if (!this.convexUrl) {
      // Return default metrics if not found
      return {
        dealsCompleted: 0,
        totalProfit: 0,
        totalRevenue: 0,
        conversionRate: 0,
        averageResponseTime: 0,
        averageNegotiationRounds: 0,
        activeListings: 0,
        emailsProcessed: 0,
        lastUpdated: new Date(),
      };
    }

    const metrics = await this.client.query(api.getMetrics, {});
    if (!metrics) {
      return {
        dealsCompleted: 0,
        totalProfit: 0,
        totalRevenue: 0,
        conversionRate: 0,
        averageResponseTime: 0,
        averageNegotiationRounds: 0,
        activeListings: 0,
        emailsProcessed: 0,
        lastUpdated: new Date(),
      };
    }

    return {
      dealsCompleted: metrics.dealsCompleted,
      totalProfit: metrics.totalProfit,
      totalRevenue: metrics.totalRevenue,
      conversionRate: metrics.conversionRate,
      averageResponseTime: metrics.averageResponseTime,
      averageNegotiationRounds: metrics.averageNegotiationRounds,
      activeListings: metrics.activeListings,
      emailsProcessed: metrics.emailsProcessed,
      lastUpdated: new Date(metrics.lastUpdated),
    };
  }

  async updateMetrics(updates: Partial<Metrics>): Promise<void> {
    if (!this.convexUrl) {
      return;
    }
    await this.client.mutation(api.updateMetrics, {
      dealsCompleted: updates.dealsCompleted,
      totalProfit: updates.totalProfit,
      totalRevenue: updates.totalRevenue,
      conversionRate: updates.conversionRate,
      averageResponseTime: updates.averageResponseTime,
      averageNegotiationRounds: updates.averageNegotiationRounds,
      activeListings: updates.activeListings,
      emailsProcessed: updates.emailsProcessed,
    });
  }

  // Helper methods
  private generateId(): string {
    return `${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
  }

  private schemaToTransaction(schema: TransactionSchema): Transaction {
    return {
      id: schema._id,
      buyerEmail: schema.buyerEmail,
      product: schema.product,
      productId: schema.productId,
      initialPrice: schema.initialPrice,
      finalPrice: schema.finalPrice,
      cost: schema.cost,
      profit: schema.profit,
      status: schema.status,
      createdAt: schema._creationTime,
      completedAt: schema.completedAt,
      negotiationRounds: schema.negotiationRounds,
      listingUrls: schema.listingUrls,
    };
  }

  private schemaToProduct(schema: ProductSchema): Product {
    return {
      id: schema._id,
      title: schema.title,
      description: schema.description,
      cost: schema.cost,
      targetPrice: schema.targetPrice,
      category: schema.category,
      images: schema.images,
      condition: schema.condition,
      createdAt: new Date(schema._creationTime),
    };
  }

  private schemaToNegotiation(schema: NegotiationStateSchema): NegotiationState {
    return {
      id: schema._id,
      buyerEmail: schema.buyerEmail,
      product: schema.product,
      threadId: schema.threadId,
      currentPrice: schema.currentPrice,
      initialPrice: schema.initialPrice,
      minPrice: schema.minPrice,
      rounds: schema.rounds,
      offers: schema.offers.map(offer => ({
        price: offer.price,
        from: offer.from,
        timestamp: new Date(offer.timestamp),
      })),
      status: schema.status,
      listingUrls: schema.listingUrls,
      agreedPrice: schema.agreedPrice,
    };
  }

  // Additional helper methods for orchestrator
  async getAllTransactions(): Promise<Transaction[]> {
    if (this.useMockMode) {
      return Array.from(this.mockTransactions.values()).map(t => this.schemaToTransaction(t));
    }
    if (!api) return [];
    const transactions = await this.client!.query(api.getAllTransactions, {});
    return transactions.map((t: any) => this.schemaToTransaction(t as TransactionSchema));
  }

  async getProductByName(name: string): Promise<Product | null> {
    if (this.useMockMode) {
      const product = Array.from(this.mockProducts.values()).find(p => p.title === name);
      return product ? this.schemaToProduct(product) : null;
    }
    if (!api) return null;
    const product = await this.client!.query(api.getProductByName, { name });
    return product ? this.schemaToProduct(product as ProductSchema) : null;
  }

  async getNegotiationByThread(threadId: string): Promise<NegotiationState | null> {
    return this.getNegotiationState(threadId);
  }

  async createNegotiation(data: any): Promise<NegotiationState> {
    return this.createNegotiationState(data);
  }

  async updateNegotiation(id: string, updates: any): Promise<NegotiationState> {
    const negotiation = Array.from(this.mockNegotiations.values()).find(n => n._id === id);
    if (!negotiation) throw new Error('Negotiation not found');
    await this.updateNegotiationState(negotiation.threadId, updates);
    const updated = await this.getNegotiationState(negotiation.threadId);
    if (!updated) throw new Error('Failed to update negotiation');
    return updated;
  }

  // ============================================
  // EMAIL QUEUE & ACTIVITY
  // ============================================

  async queueEmail(emailData: {
    messageId: string;
    threadId?: string;
    from: string;
    to: string;
    subject: string;
    body: string;
    priority?: 'low' | 'medium' | 'high';
  }): Promise<string> {
    if (this.useMockMode) {
      return emailData.messageId; // Just return ID in mock mode
    }
    if (!api) return emailData.messageId;

    try {
      // Use function name directly as string
      const emailId = await this.client!.mutation(api?.emails?.queueEmail || "emails:queueEmail" as any, emailData);
      return emailId;
    } catch (error: any) {
      console.warn('⚠️  Failed to queue email in Convex:', error.message);
      return emailData.messageId;
    }
  }

  async logActivity(activity: {
    emailId: string;
    type: 'received' | 'sent' | 'analyzed' | 'error';
    from: string;
    to: string;
    subject: string;
    summary: string;
    metadata?: any;
  }): Promise<void> {
    if (this.useMockMode) return;
    if (!api) return;

    try {
      await this.client!.mutation(api?.emails?.logActivity || "emails:logActivity" as any, activity);
    } catch (error: any) {
      console.warn('⚠️  Failed to log activity in Convex:', error.message);
    }
  }

  async updateEmailStatus(
    emailId: string,
    status: 'pending' | 'processing' | 'completed' | 'failed',
    error?: string,
    metadata?: any
  ): Promise<void> {
    if (this.useMockMode) return;
    if (!api) return;

    try {
      await this.client!.mutation(api?.emails?.updateEmailStatus || "emails:updateEmailStatus" as any, {
        emailId,
        status,
        error,
        metadata,
      });
    } catch (error: any) {
      console.warn('⚠️  Failed to update email status in Convex:', error.message);
    }
  }

  async getRecentActivity(limit: number = 50): Promise<any[]> {
    if (this.useMockMode) return [];
    if (!api) return [];

    try {
      const activities = await this.client!.query(api?.emails?.getRecentActivity || "emails:getRecentActivity" as any, { limit });
      return activities;
    } catch (error: any) {
      console.warn('⚠️  Failed to get activity from Convex:', error.message);
      return [];
    }
  }

  async getPendingEmails(limit: number = 10): Promise<any[]> {
    if (this.useMockMode) return [];
    if (!api) return [];

    try {
      const emails = await this.client!.query(api?.emails?.getPendingEmails || "emails:getPendingEmails" as any, { limit });
      return emails;
    } catch (error: any) {
      console.warn('⚠️  Failed to get pending emails from Convex:', error.message);
      return [];
    }
  }

  async getQueueStats(): Promise<{
    total: number;
    pending: number;
    processing: number;
    completed: number;
    failed: number;
  }> {
    if (this.useMockMode) {
      return { total: 0, pending: 0, processing: 0, completed: 0, failed: 0 };
    }
    if (!api) {
      return { total: 0, pending: 0, processing: 0, completed: 0, failed: 0 };
    }

    try {
      const stats = await this.client!.query(api?.emails?.getQueueStats || "emails:getQueueStats" as any, {});
      return stats;
    } catch (error: any) {
      console.warn('⚠️  Failed to get queue stats from Convex:', error.message);
      return { total: 0, pending: 0, processing: 0, completed: 0, failed: 0 };
    }
  }

  async getEmailByMessageId(messageId: string): Promise<any | null> {
    if (this.useMockMode) return null;
    if (!api) return null;

    try {
      const email = await this.client!.query(api?.emails?.getByMessageId || "emails:getByMessageId" as any, { messageId });
      return email;
    } catch (error: any) {
      console.warn('⚠️  Failed to get email by message ID from Convex:', error.message);
      return null;
    }
  }
}
