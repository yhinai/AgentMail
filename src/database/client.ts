// Convex database client for ProfitPilot
import { ConvexHttpClient } from 'convex/browser';
import {
  TransactionSchema,
  ProductSchema,
  BuyerProfileSchema,
  NegotiationStateSchema,
  MetricsSchema,
} from './models';
import type { LegacyTransaction, Product, BuyerProfile, NegotiationState, Metrics } from '../types';
// Import Convex API functions
// Note: These need to be generated by Convex after running `npx convex dev`
// For now, we'll use a dynamic import pattern
let api: any;
try {
  // Try to import from generated convex directory
  api = require('../../convex/_generated/api');
} catch {
  // Fallback: API will be undefined, will use mock mode
  console.warn('Convex API not generated. Run `npx convex dev` to generate.');
}

// Helper to safely access API functions
function getApiFunction(path: string) {
  if (!api) return undefined;
  const parts = path.split('.');
  let current: any = api;
  for (const part of parts) {
    if (current && typeof current === 'object' && part in current) {
      current = current[part];
    } else {
      return undefined;
    }
  }
  return current;
}

export class DatabaseClient {
  private client: ConvexHttpClient;
  private convexUrl: string;

  constructor() {
    this.convexUrl = process.env.NEXT_PUBLIC_CONVEX_URL || process.env.CONVEX_URL || '';
    if (!this.convexUrl) {
      console.warn('Convex URL not configured. Using mock mode.');
    }
    this.client = new ConvexHttpClient(this.convexUrl);
  }

  // Transaction operations (legacy schema)
  async createTransaction(data: Omit<LegacyTransaction, 'id' | 'createdAt'>): Promise<LegacyTransaction> {
    if (!this.convexUrl) {
      // Mock implementation when Convex not configured
      const now = Date.now();
      const transaction: TransactionSchema = {
        _id: this.generateId(),
        _creationTime: now,
        buyerEmail: data.buyerEmail,
        product: data.product,
        productId: data.productId,
        initialPrice: data.initialPrice,
        finalPrice: data.finalPrice,
        cost: data.cost,
        profit: data.profit,
        status: data.status,
        negotiationRounds: data.negotiationRounds,
        listingUrls: data.listingUrls,
        completedAt: data.completedAt ? new Date(data.completedAt).getTime() : undefined,
      };
      return this.schemaToTransaction(transaction);
    }

    // Real Convex mutation
    const createTransactionFn = getApiFunction('legacy.createTransaction');
    if (!createTransactionFn) {
      throw new Error('Convex API not available. Run `npx convex dev` first.');
    }
    const transactionId = await this.client.mutation(createTransactionFn, {
      buyerEmail: data.buyerEmail,
      product: data.product,
      productId: data.productId,
      initialPrice: data.initialPrice,
      finalPrice: data.finalPrice,
      cost: data.cost,
      profit: data.profit,
      status: data.status,
      negotiationRounds: data.negotiationRounds,
      listingUrls: data.listingUrls,
      completedAt: data.completedAt ? new Date(data.completedAt).getTime() : undefined,
    });

    const getTransactionFn = getApiFunction('legacy.getTransaction');
    if (!getTransactionFn) throw new Error('Convex API not available');
    const transaction = await this.client.query(getTransactionFn, { id: transactionId });
    if (!transaction) {
      throw new Error('Failed to create transaction');
    }
    return this.schemaToTransaction(transaction as TransactionSchema);
  }

  async getTransaction(id: string): Promise<LegacyTransaction | null> {
    if (!this.convexUrl) {
      return null;
    }
    const getTransactionFn = getApiFunction('legacy.getTransaction');
    if (!getTransactionFn) return null;
    const transaction = await this.client.query(getTransactionFn, { id: id as any });
    return transaction ? this.schemaToTransaction(transaction as TransactionSchema) : null;
  }

  async updateTransaction(id: string, updates: Partial<LegacyTransaction>): Promise<LegacyTransaction> {
    if (!this.convexUrl) {
      throw new Error('Convex not configured');
    }
    const updateTransactionFn = getApiFunction('legacy.updateTransaction');
    if (!updateTransactionFn) throw new Error('Convex API not available');
    await this.client.mutation(updateTransactionFn, {
      id: id as any,
      updates: {
        status: updates.status,
        finalPrice: updates.finalPrice,
        profit: updates.profit,
        completedAt: updates.completedAt ? new Date(updates.completedAt).getTime() : undefined,
      },
    });
    const updated = await this.getTransaction(id);
    if (!updated) {
      throw new Error('Transaction not found');
    }
    return updated;
  }

  async getTransactionsByBuyer(email: string): Promise<LegacyTransaction[]> {
    if (!this.convexUrl) {
      return [];
    }
    const getTransactionsByBuyerFn = getApiFunction('legacy.getTransactionsByBuyer');
    if (!getTransactionsByBuyerFn) return [];
    const transactions = await this.client.query(getTransactionsByBuyerFn, { email });
    return transactions.map((t: any) => this.schemaToTransaction(t as TransactionSchema));
  }

  // Product operations
  async createProduct(data: Omit<Product, 'id' | 'createdAt'>): Promise<Product> {
    if (!this.convexUrl) {
      // Mock implementation
      const product: ProductSchema = {
        _id: this.generateId(),
        _creationTime: Date.now(),
        title: data.title,
        description: data.description,
        cost: data.cost,
        targetPrice: data.targetPrice,
        category: data.category,
        images: data.images,
        condition: data.condition,
      };
      return this.schemaToProduct(product);
    }

    const createProductFn = getApiFunction('legacy.createProduct');
    if (!createProductFn) throw new Error('Convex API not available');
    const productId = await this.client.mutation(createProductFn, {
      title: data.title,
      description: data.description,
      cost: data.cost,
      targetPrice: data.targetPrice,
      category: data.category,
      images: data.images,
      condition: data.condition,
    });

    const getProductFn = getApiFunction('legacy.getProduct');
    if (!getProductFn) throw new Error('Convex API not available');
    const product = await this.client.query(getProductFn, { id: productId });
    if (!product) {
      throw new Error('Failed to create product');
    }
    return this.schemaToProduct(product as ProductSchema);
  }

  async getProduct(id: string): Promise<Product | null> {
    if (!this.convexUrl) {
      return null;
    }
    const getProductFn = getApiFunction('legacy.getProduct');
    if (!getProductFn) return null;
    const product = await this.client.query(getProductFn, { id: id as any });
    return product ? this.schemaToProduct(product as ProductSchema) : null;
  }

  async getAllProducts(): Promise<Product[]> {
    if (!this.convexUrl) {
      return [];
    }
    const getAllProductsFn = getApiFunction('legacy.getAllProducts');
    if (!getAllProductsFn) return [];
    const products = await this.client.query(getAllProductsFn, {});
    return products.map((p: any) => this.schemaToProduct(p as ProductSchema));
  }

  // Buyer Profile operations
  async getBuyerProfile(email: string): Promise<BuyerProfile | null> {
    if (!this.convexUrl) {
      return null;
    }
    const getBuyerProfileFn = getApiFunction('legacy.getBuyerProfile');
    if (!getBuyerProfileFn) return null;
    const profile = await this.client.query(getBuyerProfileFn, { email });
    return profile ? this.schemaToBuyerProfile(profile as BuyerProfileSchema) : null;
  }

  async updateBuyerProfile(email: string, updates: Partial<BuyerProfileSchema>): Promise<void> {
    if (!this.convexUrl) {
      return;
    }
    const updateBuyerProfileFn = getApiFunction('legacy.updateBuyerProfile');
    if (!updateBuyerProfileFn) return;
    await this.client.mutation(updateBuyerProfileFn, { email, updates });
  }

  private schemaToBuyerProfile(schema: BuyerProfileSchema): BuyerProfile {
    return {
      email: schema.email,
      purchaseHistory: [],
      priceSensitivity: schema.priceSensitivity,
      negotiationStyle: schema.negotiationStyle,
      communicationPreference: schema.communicationPreference,
      conversionProbability: 0.5,
      lastInteraction: schema.lastInteraction ? new Date(schema.lastInteraction) : undefined,
      totalSpent: schema.totalSpent,
      averageDiscount: schema.averageDiscount,
    };
  }

  // Negotiation State operations
  async createNegotiationState(data: Omit<NegotiationState, 'id'>): Promise<NegotiationState> {
    if (!this.convexUrl) {
      // Mock implementation
      const negotiation: NegotiationStateSchema = {
        _id: this.generateId(),
        _creationTime: Date.now(),
        buyerEmail: data.buyerEmail,
        product: data.product,
        threadId: data.threadId,
        currentPrice: data.currentPrice,
        initialPrice: data.initialPrice,
        minPrice: data.minPrice,
        rounds: data.rounds,
        offers: data.offers.map(offer => ({
          price: offer.price,
          from: offer.from,
          timestamp: offer.timestamp.getTime(),
        })),
        status: data.status,
        listingUrls: data.listingUrls,
        agreedPrice: data.agreedPrice,
      };
      return this.schemaToNegotiation(negotiation);
    }

    const createNegotiationStateFn = getApiFunction('legacy.createNegotiationState');
    if (!createNegotiationStateFn) throw new Error('Convex API not available');
    const negotiationId = await this.client.mutation(createNegotiationStateFn, {
      buyerEmail: data.buyerEmail,
      product: data.product,
      threadId: data.threadId,
      currentPrice: data.currentPrice,
      initialPrice: data.initialPrice,
      minPrice: data.minPrice,
      rounds: data.rounds,
      offers: data.offers.map(offer => ({
        price: offer.price,
        from: offer.from,
        timestamp: offer.timestamp.getTime(),
      })),
      status: data.status,
      listingUrls: data.listingUrls,
      agreedPrice: data.agreedPrice,
    });

    const getNegotiationStateFn = getApiFunction('legacy.getNegotiationState');
    if (!getNegotiationStateFn) throw new Error('Convex API not available');
    const negotiation = await this.client.query(getNegotiationStateFn, { threadId: data.threadId });
    if (!negotiation) {
      throw new Error('Failed to create negotiation state');
    }
    return this.schemaToNegotiation(negotiation as NegotiationStateSchema);
  }

  async getNegotiationState(threadId: string): Promise<NegotiationState | null> {
    if (!this.convexUrl) {
      return null;
    }
    const getNegotiationStateFn = getApiFunction('legacy.getNegotiationState');
    if (!getNegotiationStateFn) return null;
    const negotiation = await this.client.query(getNegotiationStateFn, { threadId });
    return negotiation ? this.schemaToNegotiation(negotiation as NegotiationStateSchema) : null;
  }

  async updateNegotiationState(threadId: string, updates: Partial<NegotiationState>): Promise<void> {
    if (!this.convexUrl) {
      return;
    }
    const updateNegotiationStateFn = getApiFunction('legacy.updateNegotiationState');
    if (!updateNegotiationStateFn) return;
    await this.client.mutation(updateNegotiationStateFn, {
      threadId,
      updates: {
        currentPrice: updates.currentPrice,
        rounds: updates.rounds,
        offers: updates.offers?.map(offer => ({
          price: offer.price,
          from: offer.from,
          timestamp: offer.timestamp.getTime(),
        })),
        status: updates.status,
        agreedPrice: updates.agreedPrice,
      },
    });
  }

  // Metrics operations
  async getMetrics(): Promise<Metrics> {
    if (!this.convexUrl) {
      // Return default metrics if not found
      return {
        dealsCompleted: 0,
        totalProfit: 0,
        totalRevenue: 0,
        conversionRate: 0,
        averageResponseTime: 0,
        averageNegotiationRounds: 0,
        activeListings: 0,
        emailsProcessed: 0,
        lastUpdated: new Date(),
      };
    }

    const getMetricsFn = getApiFunction('legacy.getMetrics');
    if (!getMetricsFn) {
      // Return default metrics if API not available
      return {
        dealsCompleted: 0,
        totalProfit: 0,
        totalRevenue: 0,
        conversionRate: 0,
        averageResponseTime: 0,
        averageNegotiationRounds: 0,
        activeListings: 0,
        emailsProcessed: 0,
        lastUpdated: new Date(),
      };
    }
    const metrics = await this.client.query(getMetricsFn, {});
    if (!metrics) {
      return {
        dealsCompleted: 0,
        totalProfit: 0,
        totalRevenue: 0,
        conversionRate: 0,
        averageResponseTime: 0,
        averageNegotiationRounds: 0,
        activeListings: 0,
        emailsProcessed: 0,
        lastUpdated: new Date(),
      };
    }

    return {
      dealsCompleted: metrics.dealsCompleted,
      totalProfit: metrics.totalProfit,
      totalRevenue: metrics.totalRevenue,
      conversionRate: metrics.conversionRate,
      averageResponseTime: metrics.averageResponseTime,
      averageNegotiationRounds: metrics.averageNegotiationRounds,
      activeListings: metrics.activeListings,
      emailsProcessed: metrics.emailsProcessed,
      lastUpdated: new Date(metrics.lastUpdated),
    };
  }

  async updateMetrics(updates: Partial<Metrics>): Promise<void> {
    if (!this.convexUrl) {
      return;
    }
    const updateMetricsFn = getApiFunction('legacy.updateMetrics');
    if (!updateMetricsFn) return;
    await this.client.mutation(updateMetricsFn, {
      dealsCompleted: updates.dealsCompleted,
      totalProfit: updates.totalProfit,
      totalRevenue: updates.totalRevenue,
      conversionRate: updates.conversionRate,
      averageResponseTime: updates.averageResponseTime,
      averageNegotiationRounds: updates.averageNegotiationRounds,
      activeListings: updates.activeListings,
      emailsProcessed: updates.emailsProcessed,
    });
  }

  // Helper methods
  private generateId(): string {
    return `${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
  }

  private schemaToTransaction(schema: TransactionSchema): LegacyTransaction {
    return {
      id: schema._id,
      buyerEmail: schema.buyerEmail,
      product: schema.product,
      productId: schema.productId,
      initialPrice: schema.initialPrice,
      finalPrice: schema.finalPrice,
      cost: schema.cost,
      profit: schema.profit,
      status: schema.status,
      createdAt: new Date(schema._creationTime),
      completedAt: schema.completedAt ? new Date(schema.completedAt) : undefined,
      negotiationRounds: schema.negotiationRounds,
      listingUrls: schema.listingUrls,
    };
  }

  private schemaToProduct(schema: ProductSchema): Product {
    return {
      id: schema._id,
      title: schema.title,
      description: schema.description,
      cost: schema.cost,
      targetPrice: schema.targetPrice,
      category: schema.category,
      images: schema.images,
      condition: schema.condition,
      createdAt: new Date(schema._creationTime),
    };
  }

  private schemaToNegotiation(schema: NegotiationStateSchema): NegotiationState {
    return {
      id: schema._id,
      buyerEmail: schema.buyerEmail,
      product: schema.product,
      threadId: schema.threadId,
      currentPrice: schema.currentPrice,
      initialPrice: schema.initialPrice,
      minPrice: schema.minPrice,
      rounds: schema.rounds,
      offers: schema.offers.map(offer => ({
        price: offer.price,
        from: offer.from,
        timestamp: new Date(offer.timestamp),
      })),
      status: schema.status,
      listingUrls: schema.listingUrls,
      agreedPrice: schema.agreedPrice,
    };
  }

  // ============================================
  // EMAIL OPERATIONS (AgentMail Integration)
  // ============================================

  /**
   * Queue an email for processing
   */
  async queueEmail(emailData: {
    messageId: string;
    threadId?: string;
    from: string;
    to: string;
    subject: string;
    body: string;
    receivedAt: Date;
    priority?: 'low' | 'medium' | 'high';
    metadata?: any;
  }): Promise<string> {
    if (!this.client) {
      throw new Error('Convex client not initialized');
    }

    // Use string-based API call as fallback when generated API isn't available
    const queueEmailFn = getApiFunction('emails.queueEmail') || 'emails:queueEmail' as any;

    const emailId = await this.client.mutation(queueEmailFn, {
      messageId: emailData.messageId,
      threadId: emailData.threadId,
      from: emailData.from,
      to: emailData.to,
      subject: emailData.subject,
      body: emailData.body,
      receivedAt: emailData.receivedAt.getTime(),
      priority: emailData.priority || 'medium',
      metadata: emailData.metadata,
    });

    return emailId;
  }

  /**
   * Get pending emails from queue
   */
  async getPendingEmails(limit: number = 10): Promise<any[]> {
    if (!this.client) {
      return [];
    }

    const getPendingEmailsFn = getApiFunction('emails.getPendingEmails') || 'emails:getPendingEmails' as any;

    const emails = await this.client.query(getPendingEmailsFn, { limit });
    return emails || [];
  }

  /**
   * Get email queue statistics
   */
  async getQueueStats(): Promise<{
    total: number;
    pending: number;
    processing: number;
    completed: number;
    failed: number;
  }> {
    if (!this.client) {
      return { total: 0, pending: 0, processing: 0, completed: 0, failed: 0 };
    }

    const getQueueStatsFn = getApiFunction('emails.getQueueStats') || 'emails:getQueueStats' as any;

    const stats = await this.client.query(getQueueStatsFn, {});
    return stats || { total: 0, pending: 0, processing: 0, completed: 0, failed: 0 };
  }

  /**
   * Get email by message ID
   */
  async getEmailByMessageId(messageId: string): Promise<any | null> {
    if (!this.client) {
      return null;
    }

    const getEmailByMessageIdFn = getApiFunction('emails.getByMessageId') || 'emails:getByMessageId' as any;

    const email = await this.client.query(getEmailByMessageIdFn, { messageId });
    return email || null;
  }

  /**
   * Update email status
   */
  async updateEmailStatus(params: {
    emailId: string;
    status: 'pending' | 'processing' | 'completed' | 'failed';
    error?: string;
    metadata?: any;
  }): Promise<void> {
    if (!this.client) {
      throw new Error('Convex client not initialized');
    }

    const updateStatusFn = getApiFunction('emails.updateEmailStatus') || 'emails:updateEmailStatus' as any;

    await this.client.mutation(updateStatusFn, {
      emailId: params.emailId as any,
      status: params.status,
      error: params.error,
      metadata: params.metadata,
    });
  }

  /**
   * Log email activity (alias for logEmailActivity)
   */
  async logActivity(activity: {
    emailId: string;
    type: 'received' | 'sent' | 'analyzed' | 'error';
    from: string;
    to?: string;
    subject: string;
    summary: string;
    metadata?: any;
  }): Promise<string> {
    return this.logEmailActivity(activity);
  }

  /**
   * Log email activity
   */
  async logEmailActivity(activity: {
    emailId: string;
    type: 'received' | 'sent' | 'analyzed' | 'error';
    from: string;
    to?: string;
    subject: string;
    summary: string;
    metadata?: any;
  }): Promise<string> {
    if (!this.client) {
      throw new Error('Convex client not initialized');
    }

    const logActivityFn = getApiFunction('emails.logActivity') || 'emails:logActivity' as any;

    const activityId = await this.client.mutation(logActivityFn, {
      ...activity,
      timestamp: Date.now(),
    });

    return activityId;
  }

  /**
   * Get recent email activity
   */
  async getRecentActivity(limit: number = 50): Promise<any[]> {
    if (!this.client) {
      return [];
    }

    const getRecentActivityFn = getApiFunction('emails.getRecentActivity') || 'emails:getRecentActivity' as any;

    const activities = await this.client.query(getRecentActivityFn, { limit });
    return activities || [];
  }
}
